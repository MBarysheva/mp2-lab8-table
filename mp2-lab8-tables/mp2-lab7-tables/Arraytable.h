#pragma once
#ifndef _arraytable_h
#define _arraytable_h

#include "table.h"

#define TabMaxSize 1000

enum TDataPos { FIRST_POS, CURRENT_POS, LAST_POS };

class TArrayTable : public TTable {

protected:
	//TTabRecord *pRecs; // память для записей таблицы// table memory
	int TabSize; //максимально возможное количество записей в таблицу// max count of records
	int CurrPos; //номер текущей записи(начиная с 0)// current record numder(staring from 0)

public:
	TTabRecord* pRecs; // память для записей таблицы// table memory
	TArrayTable() {
		TabSize = -1;
		pRecs = NULL;
		CurrPos = -1;
	};
	TArrayTable(int Size = TabMaxSize) {
		pRecs = new TTabRecord[Size];
		TabSize = Size;
		DataCount = CurrPos = 0;
	}
	 ~TArrayTable() {
		delete[] pRecs;
	}

	//информационные методы// informational metods
	virtual bool IsFull() const {
		return DataCount >= TabSize;
	}

	int GetTabSize() const {
		return TabSize;
	}

	//доступ//access
	virtual TKey GetKey(void) const {
		return GetKey(CURRENT_POS);
	}
	virtual TValue GetValue(void) const {
		return GetValue(CURRENT_POS);
	}
	virtual TKey GetKey(TDataPos mode) const;
	virtual TValue GetValue(TDataPos mode) const;

	//навигация//navigation
	virtual int Reset(void);
	virtual int IsTabEnded(void) const;
	virtual int GoNext(void);
	virtual int SetCurrentPos(int pos);
	int GetCurrentPos(void) const {
		return CurrPos;
	}

	friend class SortTable;
};
#endif